// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/streamit.proto

#include "proto/streamit.grpc.pb.h"
#include "proto/streamit.pb.h"

#include <functional>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/ports_def.inc>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/support/sync_stream.h>
namespace streamit {
namespace v1 {

static const char* Broker_method_names[] = {
    "/streamit.v1.Broker/Produce",
    "/streamit.v1.Broker/Fetch",
};

std::unique_ptr<Broker::Stub> Broker::NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                              const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr<Broker::Stub> stub(new Broker::Stub(channel, options));
  return stub;
}

Broker::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
    : channel_(channel), rpcmethod_Produce_(Broker_method_names[0], options.suffix_for_stats(),
                                            ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_Fetch_(Broker_method_names[1], options.suffix_for_stats(), ::grpc::internal::RpcMethod::NORMAL_RPC,
                       channel) {
}

::grpc::Status Broker::Stub::Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request,
                                     ::streamit::v1::ProduceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse,
                                             ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_Produce_, context, request, response);
}

void Broker::Stub::async::Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                                  ::streamit::v1::ProduceResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_Produce_, context, request, response, std::move(f));
}

void Broker::Stub::async::Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                                  ::streamit::v1::ProduceResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_Produce_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>* Broker::Stub::PrepareAsyncProduceRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::ProduceResponse, ::streamit::v1::ProduceRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Produce_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>* Broker::Stub::AsyncProduceRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncProduceRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Broker::Stub::Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request,
                                   ::streamit::v1::FetchResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse,
                                             ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_Fetch_, context, request, response);
}

void Broker::Stub::async::Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                                ::streamit::v1::FetchResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_Fetch_, context, request, response, std::move(f));
}

void Broker::Stub::async::Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                                ::streamit::v1::FetchResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_Fetch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>* Broker::Stub::PrepareAsyncFetchRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::FetchResponse, ::streamit::v1::FetchRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Fetch_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>* Broker::Stub::AsyncFetchRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncFetchRaw(context, request, cq);
  result->StartCall();
  return result;
}

Broker::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Broker_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Broker::Service, ::streamit::v1::ProduceRequest,
                                             ::streamit::v1::ProduceResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Broker::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::ProduceRequest* req,
             ::streamit::v1::ProduceResponse* resp) { return service->Produce(ctx, req, resp); },
          this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Broker_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Broker::Service, ::streamit::v1::FetchRequest,
                                             ::streamit::v1::FetchResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Broker::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::FetchRequest* req,
             ::streamit::v1::FetchResponse* resp) { return service->Fetch(ctx, req, resp); },
          this)));
}

Broker::Service::~Service() {
}

::grpc::Status Broker::Service::Produce(::grpc::ServerContext* context, const ::streamit::v1::ProduceRequest* request,
                                        ::streamit::v1::ProduceResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Broker::Service::Fetch(::grpc::ServerContext* context, const ::streamit::v1::FetchRequest* request,
                                      ::streamit::v1::FetchResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

static const char* Coordinator_method_names[] = {
    "/streamit.v1.Coordinator/CommitOffset",
    "/streamit.v1.Coordinator/PollAssignment",
};

std::unique_ptr<Coordinator::Stub> Coordinator::NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                                        const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr<Coordinator::Stub> stub(new Coordinator::Stub(channel, options));
  return stub;
}

Coordinator::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
    : channel_(channel), rpcmethod_CommitOffset_(Coordinator_method_names[0], options.suffix_for_stats(),
                                                 ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_PollAssignment_(Coordinator_method_names[1], options.suffix_for_stats(),
                                ::grpc::internal::RpcMethod::NORMAL_RPC, channel) {
}

::grpc::Status Coordinator::Stub::CommitOffset(::grpc::ClientContext* context,
                                               const ::streamit::v1::CommitOffsetRequest& request,
                                               ::streamit::v1::CommitOffsetResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::CommitOffsetRequest, ::streamit::v1::CommitOffsetResponse,
                                             ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_CommitOffset_, context, request, response);
}

void Coordinator::Stub::async::CommitOffset(::grpc::ClientContext* context,
                                            const ::streamit::v1::CommitOffsetRequest* request,
                                            ::streamit::v1::CommitOffsetResponse* response,
                                            std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::CommitOffsetRequest, ::streamit::v1::CommitOffsetResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_CommitOffset_, context, request, response, std::move(f));
}

void Coordinator::Stub::async::CommitOffset(::grpc::ClientContext* context,
                                            const ::streamit::v1::CommitOffsetRequest* request,
                                            ::streamit::v1::CommitOffsetResponse* response,
                                            ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_CommitOffset_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>* Coordinator::Stub::PrepareAsyncCommitOffsetRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::CommitOffsetResponse, ::streamit::v1::CommitOffsetRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CommitOffset_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>* Coordinator::Stub::AsyncCommitOffsetRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncCommitOffsetRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Coordinator::Stub::PollAssignment(::grpc::ClientContext* context,
                                                 const ::streamit::v1::PollAssignmentRequest& request,
                                                 ::streamit::v1::PollAssignmentResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::PollAssignmentRequest,
                                             ::streamit::v1::PollAssignmentResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_PollAssignment_,
                                                                            context, request, response);
}

void Coordinator::Stub::async::PollAssignment(::grpc::ClientContext* context,
                                              const ::streamit::v1::PollAssignmentRequest* request,
                                              ::streamit::v1::PollAssignmentResponse* response,
                                              std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::PollAssignmentRequest, ::streamit::v1::PollAssignmentResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_PollAssignment_, context, request, response, std::move(f));
}

void Coordinator::Stub::async::PollAssignment(::grpc::ClientContext* context,
                                              const ::streamit::v1::PollAssignmentRequest* request,
                                              ::streamit::v1::PollAssignmentResponse* response,
                                              ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_PollAssignment_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>*
Coordinator::Stub::PrepareAsyncPollAssignmentRaw(::grpc::ClientContext* context,
                                                 const ::streamit::v1::PollAssignmentRequest& request,
                                                 ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::PollAssignmentResponse, ::streamit::v1::PollAssignmentRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_PollAssignment_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>* Coordinator::Stub::AsyncPollAssignmentRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncPollAssignmentRaw(context, request, cq);
  result->StartCall();
  return result;
}

Coordinator::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Coordinator_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Coordinator::Service, ::streamit::v1::CommitOffsetRequest,
                                             ::streamit::v1::CommitOffsetResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Coordinator::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::CommitOffsetRequest* req,
             ::streamit::v1::CommitOffsetResponse* resp) { return service->CommitOffset(ctx, req, resp); },
          this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Coordinator_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Coordinator::Service, ::streamit::v1::PollAssignmentRequest,
                                             ::streamit::v1::PollAssignmentResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Coordinator::Service* service, ::grpc::ServerContext* ctx,
             const ::streamit::v1::PollAssignmentRequest* req,
             ::streamit::v1::PollAssignmentResponse* resp) { return service->PollAssignment(ctx, req, resp); },
          this)));
}

Coordinator::Service::~Service() {
}

::grpc::Status Coordinator::Service::CommitOffset(::grpc::ServerContext* context,
                                                  const ::streamit::v1::CommitOffsetRequest* request,
                                                  ::streamit::v1::CommitOffsetResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Coordinator::Service::PollAssignment(::grpc::ServerContext* context,
                                                    const ::streamit::v1::PollAssignmentRequest* request,
                                                    ::streamit::v1::PollAssignmentResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

static const char* Controller_method_names[] = {
    "/streamit.v1.Controller/CreateTopic",
    "/streamit.v1.Controller/DescribeTopic",
    "/streamit.v1.Controller/FindLeader",
};

std::unique_ptr<Controller::Stub> Controller::NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                                      const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr<Controller::Stub> stub(new Controller::Stub(channel, options));
  return stub;
}

Controller::Stub::Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
    : channel_(channel), rpcmethod_CreateTopic_(Controller_method_names[0], options.suffix_for_stats(),
                                                ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_DescribeTopic_(Controller_method_names[1], options.suffix_for_stats(),
                               ::grpc::internal::RpcMethod::NORMAL_RPC, channel),
      rpcmethod_FindLeader_(Controller_method_names[2], options.suffix_for_stats(),
                            ::grpc::internal::RpcMethod::NORMAL_RPC, channel) {
}

::grpc::Status Controller::Stub::CreateTopic(::grpc::ClientContext* context,
                                             const ::streamit::v1::CreateTopicRequest& request,
                                             ::streamit::v1::CreateTopicResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::CreateTopicRequest, ::streamit::v1::CreateTopicResponse,
                                             ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_CreateTopic_, context, request, response);
}

void Controller::Stub::async::CreateTopic(::grpc::ClientContext* context,
                                          const ::streamit::v1::CreateTopicRequest* request,
                                          ::streamit::v1::CreateTopicResponse* response,
                                          std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::CreateTopicRequest, ::streamit::v1::CreateTopicResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_CreateTopic_, context, request, response, std::move(f));
}

void Controller::Stub::async::CreateTopic(::grpc::ClientContext* context,
                                          const ::streamit::v1::CreateTopicRequest* request,
                                          ::streamit::v1::CreateTopicResponse* response,
                                          ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_CreateTopic_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>* Controller::Stub::PrepareAsyncCreateTopicRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::CreateTopicResponse, ::streamit::v1::CreateTopicRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_CreateTopic_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>* Controller::Stub::AsyncCreateTopicRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncCreateTopicRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Controller::Stub::DescribeTopic(::grpc::ClientContext* context,
                                               const ::streamit::v1::DescribeTopicRequest& request,
                                               ::streamit::v1::DescribeTopicResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::DescribeTopicRequest,
                                             ::streamit::v1::DescribeTopicResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DescribeTopic_,
                                                                            context, request, response);
}

void Controller::Stub::async::DescribeTopic(::grpc::ClientContext* context,
                                            const ::streamit::v1::DescribeTopicRequest* request,
                                            ::streamit::v1::DescribeTopicResponse* response,
                                            std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::DescribeTopicRequest, ::streamit::v1::DescribeTopicResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_DescribeTopic_, context, request, response, std::move(f));
}

void Controller::Stub::async::DescribeTopic(::grpc::ClientContext* context,
                                            const ::streamit::v1::DescribeTopicRequest* request,
                                            ::streamit::v1::DescribeTopicResponse* response,
                                            ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_DescribeTopic_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>*
Controller::Stub::PrepareAsyncDescribeTopicRaw(::grpc::ClientContext* context,
                                               const ::streamit::v1::DescribeTopicRequest& request,
                                               ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::DescribeTopicResponse, ::streamit::v1::DescribeTopicRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DescribeTopic_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>* Controller::Stub::AsyncDescribeTopicRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncDescribeTopicRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Controller::Stub::FindLeader(::grpc::ClientContext* context,
                                            const ::streamit::v1::FindLeaderRequest& request,
                                            ::streamit::v1::FindLeaderResponse* response) {
  return ::grpc::internal::BlockingUnaryCall<::streamit::v1::FindLeaderRequest, ::streamit::v1::FindLeaderResponse,
                                             ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      channel_.get(), rpcmethod_FindLeader_, context, request, response);
}

void Controller::Stub::async::FindLeader(::grpc::ClientContext* context,
                                         const ::streamit::v1::FindLeaderRequest* request,
                                         ::streamit::v1::FindLeaderResponse* response,
                                         std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall<::streamit::v1::FindLeaderRequest, ::streamit::v1::FindLeaderResponse,
                                      ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_FindLeader_, context, request, response, std::move(f));
}

void Controller::Stub::async::FindLeader(::grpc::ClientContext* context,
                                         const ::streamit::v1::FindLeaderRequest* request,
                                         ::streamit::v1::FindLeaderResponse* response,
                                         ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create<::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
      stub_->channel_.get(), stub_->rpcmethod_FindLeader_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>* Controller::Stub::PrepareAsyncFindLeaderRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create<
      ::streamit::v1::FindLeaderResponse, ::streamit::v1::FindLeaderRequest, ::grpc::protobuf::MessageLite,
      ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_FindLeader_, context, request);
}

::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>* Controller::Stub::AsyncFindLeaderRaw(
    ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result = this->PrepareAsyncFindLeaderRaw(context, request, cq);
  result->StartCall();
  return result;
}

Controller::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Controller_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Controller::Service, ::streamit::v1::CreateTopicRequest,
                                             ::streamit::v1::CreateTopicResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Controller::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::CreateTopicRequest* req,
             ::streamit::v1::CreateTopicResponse* resp) { return service->CreateTopic(ctx, req, resp); },
          this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Controller_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Controller::Service, ::streamit::v1::DescribeTopicRequest,
                                             ::streamit::v1::DescribeTopicResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Controller::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::DescribeTopicRequest* req,
             ::streamit::v1::DescribeTopicResponse* resp) { return service->DescribeTopic(ctx, req, resp); },
          this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Controller_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler<Controller::Service, ::streamit::v1::FindLeaderRequest,
                                             ::streamit::v1::FindLeaderResponse, ::grpc::protobuf::MessageLite,
                                             ::grpc::protobuf::MessageLite>(
          [](Controller::Service* service, ::grpc::ServerContext* ctx, const ::streamit::v1::FindLeaderRequest* req,
             ::streamit::v1::FindLeaderResponse* resp) { return service->FindLeader(ctx, req, resp); },
          this)));
}

Controller::Service::~Service() {
}

::grpc::Status Controller::Service::CreateTopic(::grpc::ServerContext* context,
                                                const ::streamit::v1::CreateTopicRequest* request,
                                                ::streamit::v1::CreateTopicResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Controller::Service::DescribeTopic(::grpc::ServerContext* context,
                                                  const ::streamit::v1::DescribeTopicRequest* request,
                                                  ::streamit::v1::DescribeTopicResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Controller::Service::FindLeader(::grpc::ServerContext* context,
                                               const ::streamit::v1::FindLeaderRequest* request,
                                               ::streamit::v1::FindLeaderResponse* response) {
  (void)context;
  (void)request;
  (void)response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

} // namespace v1
} // namespace streamit
#include <grpcpp/ports_undef.inc>
