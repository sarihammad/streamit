// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/streamit.proto
#ifndef GRPC_proto_2fstreamit_2eproto__INCLUDED
#define GRPC_proto_2fstreamit_2eproto__INCLUDED

#include "proto/streamit.pb.h"

#include <functional>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/ports_def.inc>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace streamit {
namespace v1 {

// Services
class Broker final {
public:
  static constexpr char const* service_full_name() {
    return "streamit.v1.Broker";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {
    }
    virtual ::grpc::Status Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request,
                                   ::streamit::v1::ProduceResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>> AsyncProduce(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>>(
          AsyncProduceRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>> PrepareAsyncProduce(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>>(
          PrepareAsyncProduceRaw(context, request, cq));
    }
    virtual ::grpc::Status Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request,
                                 ::streamit::v1::FetchResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>> AsyncFetch(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>>(
          AsyncFetchRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>> PrepareAsyncFetch(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>>(
          PrepareAsyncFetchRaw(context, request, cq));
    }
    class async_interface {
    public:
      virtual ~async_interface() {
      }
      virtual void Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                           ::streamit::v1::ProduceResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                           ::streamit::v1::ProduceResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                         ::streamit::v1::FetchResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                         ::streamit::v1::FetchResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() {
      return nullptr;
    }
    class async_interface* experimental_async() {
      return async();
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>* AsyncProduceRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::ProduceResponse>* PrepareAsyncProduceRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>* AsyncFetchRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FetchResponse>* PrepareAsyncFetchRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
         const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request,
                           ::streamit::v1::ProduceResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>> AsyncProduce(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>>(
          AsyncProduceRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>> PrepareAsyncProduce(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>>(
          PrepareAsyncProduceRaw(context, request, cq));
    }
    ::grpc::Status Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request,
                         ::streamit::v1::FetchResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>> AsyncFetch(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>>(
          AsyncFetchRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>> PrepareAsyncFetch(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>>(
          PrepareAsyncFetchRaw(context, request, cq));
    }
    class async final : public StubInterface::async_interface {
    public:
      void Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                   ::streamit::v1::ProduceResponse* response, std::function<void(::grpc::Status)>) override;
      void Produce(::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest* request,
                   ::streamit::v1::ProduceResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                 ::streamit::v1::FetchResponse* response, std::function<void(::grpc::Status)>) override;
      void Fetch(::grpc::ClientContext* context, const ::streamit::v1::FetchRequest* request,
                 ::streamit::v1::FetchResponse* response, ::grpc::ClientUnaryReactor* reactor) override;

    private:
      friend class Stub;
      explicit async(Stub* stub) : stub_(stub) {
      }
      Stub* stub() {
        return stub_;
      }
      Stub* stub_;
    };
    class async* async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>* AsyncProduceRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::ProduceResponse>* PrepareAsyncProduceRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::ProduceRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>* AsyncFetchRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::FetchResponse>* PrepareAsyncFetchRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FetchRequest& request,
        ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Produce_;
    const ::grpc::internal::RpcMethod rpcmethod_Fetch_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                       const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Produce(::grpc::ServerContext* context, const ::streamit::v1::ProduceRequest* request,
                                   ::streamit::v1::ProduceResponse* response);
    virtual ::grpc::Status Fetch(::grpc::ServerContext* context, const ::streamit::v1::FetchRequest* request,
                                 ::streamit::v1::FetchResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_Produce() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProduce(::grpc::ServerContext* context, ::streamit::v1::ProduceRequest* request,
                        ::grpc::ServerAsyncResponseWriter<::streamit::v1::ProduceResponse>* response,
                        ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                        void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_Fetch() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetch(::grpc::ServerContext* context, ::streamit::v1::FetchRequest* request,
                      ::grpc::ServerAsyncResponseWriter<::streamit::v1::FetchResponse>* response,
                      ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Produce<WithAsyncMethod_Fetch<Service>> AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_Produce() {
      ::grpc::Service::MarkMethodCallback(
          0,
          new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>(
              [this](::grpc::CallbackServerContext* context, const ::streamit::v1::ProduceRequest* request,
                     ::streamit::v1::ProduceResponse* response) { return this->Produce(context, request, response); }));
    }
    void SetMessageAllocatorFor_Produce(
        ::grpc::MessageAllocator<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<
          ::grpc::internal::CallbackUnaryHandler<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>*>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Produce(::grpc::CallbackServerContext* /*context*/,
                                                const ::streamit::v1::ProduceRequest* /*request*/,
                                                ::streamit::v1::ProduceResponse* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_Fetch() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::FetchRequest* request,
                        ::streamit::v1::FetchResponse* response) { return this->Fetch(context, request, response); }));
    }
    void SetMessageAllocatorFor_Fetch(
        ::grpc::MessageAllocator<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>*>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fetch(::grpc::CallbackServerContext* /*context*/,
                                              const ::streamit::v1::FetchRequest* /*request*/,
                                              ::streamit::v1::FetchResponse* /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_Produce<WithCallbackMethod_Fetch<Service>> CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_Produce() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_Fetch() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_Produce() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProduce(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                        ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                        void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_Fetch() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                      ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                      ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_Produce() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->Produce(context, request, response); }));
    }
    ~WithRawCallbackMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Produce(::grpc::CallbackServerContext* /*context*/,
                                                const ::grpc::ByteBuffer* /*request*/,
                                                ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_Fetch() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->Fetch(context, request, response); }));
    }
    ~WithRawCallbackMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fetch(::grpc::CallbackServerContext* /*context*/,
                                              const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Produce : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_Produce() {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>(
              [this](::grpc::ServerContext* context,
                     ::grpc::ServerUnaryStreamer<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>*
                         streamer) { return this->StreamedProduce(context, streamer); }));
    }
    ~WithStreamedUnaryMethod_Produce() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Produce(::grpc::ServerContext* /*context*/, const ::streamit::v1::ProduceRequest* /*request*/,
                           ::streamit::v1::ProduceResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProduce(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::ProduceRequest, ::streamit::v1::ProduceResponse>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fetch : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_Fetch() {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>(
              [this](
                  ::grpc::ServerContext* context,
                  ::grpc::ServerUnaryStreamer<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>* streamer) {
                return this->StreamedFetch(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_Fetch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fetch(::grpc::ServerContext* /*context*/, const ::streamit::v1::FetchRequest* /*request*/,
                         ::streamit::v1::FetchResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetch(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::FetchRequest, ::streamit::v1::FetchResponse>*
            server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Produce<WithStreamedUnaryMethod_Fetch<Service>> StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Produce<WithStreamedUnaryMethod_Fetch<Service>> StreamedService;
};

class Coordinator final {
public:
  static constexpr char const* service_full_name() {
    return "streamit.v1.Coordinator";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {
    }
    virtual ::grpc::Status CommitOffset(::grpc::ClientContext* context,
                                        const ::streamit::v1::CommitOffsetRequest& request,
                                        ::streamit::v1::CommitOffsetResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>> AsyncCommitOffset(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>>(
          AsyncCommitOffsetRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>>
    PrepareAsyncCommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
                             ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>>(
          PrepareAsyncCommitOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status PollAssignment(::grpc::ClientContext* context,
                                          const ::streamit::v1::PollAssignmentRequest& request,
                                          ::streamit::v1::PollAssignmentResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>>
    AsyncPollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
                        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>>(
          AsyncPollAssignmentRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>>
    PrepareAsyncPollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
                               ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>>(
          PrepareAsyncPollAssignmentRaw(context, request, cq));
    }
    class async_interface {
    public:
      virtual ~async_interface() {
      }
      virtual void CommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest* request,
                                ::streamit::v1::CommitOffsetResponse* response,
                                std::function<void(::grpc::Status)>) = 0;
      virtual void CommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest* request,
                                ::streamit::v1::CommitOffsetResponse* response,
                                ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest* request,
                                  ::streamit::v1::PollAssignmentResponse* response,
                                  std::function<void(::grpc::Status)>) = 0;
      virtual void PollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest* request,
                                  ::streamit::v1::PollAssignmentResponse* response,
                                  ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() {
      return nullptr;
    }
    class async_interface* experimental_async() {
      return async();
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>* AsyncCommitOffsetRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CommitOffsetResponse>*
    PrepareAsyncCommitOffsetRaw(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
                                ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>* AsyncPollAssignmentRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::PollAssignmentResponse>*
    PrepareAsyncPollAssignmentRaw(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
                                  ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
         const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
                                ::streamit::v1::CommitOffsetResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>> AsyncCommitOffset(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>>(
          AsyncCommitOffsetRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>> PrepareAsyncCommitOffset(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>>(
          PrepareAsyncCommitOffsetRaw(context, request, cq));
    }
    ::grpc::Status PollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
                                  ::streamit::v1::PollAssignmentResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>> AsyncPollAssignment(
        ::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>>(
          AsyncPollAssignmentRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>>
    PrepareAsyncPollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
                               ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>>(
          PrepareAsyncPollAssignmentRaw(context, request, cq));
    }
    class async final : public StubInterface::async_interface {
    public:
      void CommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest* request,
                        ::streamit::v1::CommitOffsetResponse* response, std::function<void(::grpc::Status)>) override;
      void CommitOffset(::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest* request,
                        ::streamit::v1::CommitOffsetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest* request,
                          ::streamit::v1::PollAssignmentResponse* response,
                          std::function<void(::grpc::Status)>) override;
      void PollAssignment(::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest* request,
                          ::streamit::v1::PollAssignmentResponse* response,
                          ::grpc::ClientUnaryReactor* reactor) override;

    private:
      friend class Stub;
      explicit async(Stub* stub) : stub_(stub) {
      }
      Stub* stub() {
        return stub_;
      }
      Stub* stub_;
    };
    class async* async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>* AsyncCommitOffsetRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::CommitOffsetResponse>* PrepareAsyncCommitOffsetRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CommitOffsetRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>* AsyncPollAssignmentRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::PollAssignmentResponse>* PrepareAsyncPollAssignmentRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::PollAssignmentRequest& request,
        ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CommitOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_PollAssignment_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                       const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CommitOffset(::grpc::ServerContext* context,
                                        const ::streamit::v1::CommitOffsetRequest* request,
                                        ::streamit::v1::CommitOffsetResponse* response);
    virtual ::grpc::Status PollAssignment(::grpc::ServerContext* context,
                                          const ::streamit::v1::PollAssignmentRequest* request,
                                          ::streamit::v1::PollAssignmentResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_CommitOffset() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommitOffset(::grpc::ServerContext* context, ::streamit::v1::CommitOffsetRequest* request,
                             ::grpc::ServerAsyncResponseWriter<::streamit::v1::CommitOffsetResponse>* response,
                             ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                             void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_PollAssignment() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPollAssignment(::grpc::ServerContext* context, ::streamit::v1::PollAssignmentRequest* request,
                               ::grpc::ServerAsyncResponseWriter<::streamit::v1::PollAssignmentResponse>* response,
                               ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                               void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CommitOffset<WithAsyncMethod_PollAssignment<Service>> AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_CommitOffset() {
      ::grpc::Service::MarkMethodCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::CommitOffsetRequest,
                                                        ::streamit::v1::CommitOffsetResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::CommitOffsetRequest* request,
                        ::streamit::v1::CommitOffsetResponse* response) {
                   return this->CommitOffset(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_CommitOffset(
        ::grpc::MessageAllocator<::streamit::v1::CommitOffsetRequest, ::streamit::v1::CommitOffsetResponse>*
            allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::CommitOffsetRequest,
                                                         ::streamit::v1::CommitOffsetResponse>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CommitOffset(::grpc::CallbackServerContext* /*context*/,
                                                     const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                                     ::streamit::v1::CommitOffsetResponse* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_PollAssignment() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::PollAssignmentRequest,
                                                        ::streamit::v1::PollAssignmentResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::PollAssignmentRequest* request,
                        ::streamit::v1::PollAssignmentResponse* response) {
                   return this->PollAssignment(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_PollAssignment(
        ::grpc::MessageAllocator<::streamit::v1::PollAssignmentRequest, ::streamit::v1::PollAssignmentResponse>*
            allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::PollAssignmentRequest,
                                                         ::streamit::v1::PollAssignmentResponse>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PollAssignment(::grpc::CallbackServerContext* /*context*/,
                                                       const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                                       ::streamit::v1::PollAssignmentResponse* /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_CommitOffset<WithCallbackMethod_PollAssignment<Service>> CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_CommitOffset() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_PollAssignment() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_CommitOffset() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCommitOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                             ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                             ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                             void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_PollAssignment() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPollAssignment(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                               ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                               ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                               void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_CommitOffset() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->CommitOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CommitOffset(::grpc::CallbackServerContext* /*context*/,
                                                     const ::grpc::ByteBuffer* /*request*/,
                                                     ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_PollAssignment() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->PollAssignment(context, request, response); }));
    }
    ~WithRawCallbackMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PollAssignment(::grpc::CallbackServerContext* /*context*/,
                                                       const ::grpc::ByteBuffer* /*request*/,
                                                       ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CommitOffset : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_CommitOffset() {
      ::grpc::Service::MarkMethodStreamed(
          0, new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::CommitOffsetRequest,
                                                        ::streamit::v1::CommitOffsetResponse>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerUnaryStreamer<::streamit::v1::CommitOffsetRequest,
                                                    ::streamit::v1::CommitOffsetResponse>* streamer) {
                   return this->StreamedCommitOffset(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_CommitOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CommitOffset(::grpc::ServerContext* /*context*/,
                                const ::streamit::v1::CommitOffsetRequest* /*request*/,
                                ::streamit::v1::CommitOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCommitOffset(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::CommitOffsetRequest, ::streamit::v1::CommitOffsetResponse>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PollAssignment : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_PollAssignment() {
      ::grpc::Service::MarkMethodStreamed(
          1, new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::PollAssignmentRequest,
                                                        ::streamit::v1::PollAssignmentResponse>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerUnaryStreamer<::streamit::v1::PollAssignmentRequest,
                                                    ::streamit::v1::PollAssignmentResponse>* streamer) {
                   return this->StreamedPollAssignment(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_PollAssignment() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PollAssignment(::grpc::ServerContext* /*context*/,
                                  const ::streamit::v1::PollAssignmentRequest* /*request*/,
                                  ::streamit::v1::PollAssignmentResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPollAssignment(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::PollAssignmentRequest, ::streamit::v1::PollAssignmentResponse>*
            server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CommitOffset<WithStreamedUnaryMethod_PollAssignment<Service>> StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CommitOffset<WithStreamedUnaryMethod_PollAssignment<Service>> StreamedService;
};

class Controller final {
public:
  static constexpr char const* service_full_name() {
    return "streamit.v1.Controller";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {
    }
    virtual ::grpc::Status CreateTopic(::grpc::ClientContext* context,
                                       const ::streamit::v1::CreateTopicRequest& request,
                                       ::streamit::v1::CreateTopicResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>> AsyncCreateTopic(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>>(
          AsyncCreateTopicRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>>
    PrepareAsyncCreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
                            ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>>(
          PrepareAsyncCreateTopicRaw(context, request, cq));
    }
    virtual ::grpc::Status DescribeTopic(::grpc::ClientContext* context,
                                         const ::streamit::v1::DescribeTopicRequest& request,
                                         ::streamit::v1::DescribeTopicResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>>
    AsyncDescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
                       ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>>(
          AsyncDescribeTopicRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>>
    PrepareAsyncDescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
                              ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>>(
          PrepareAsyncDescribeTopicRaw(context, request, cq));
    }
    virtual ::grpc::Status FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
                                      ::streamit::v1::FindLeaderResponse* response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>> AsyncFindLeader(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>>(
          AsyncFindLeaderRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>>
    PrepareAsyncFindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
                           ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>>(
          PrepareAsyncFindLeaderRaw(context, request, cq));
    }
    class async_interface {
    public:
      virtual ~async_interface() {
      }
      virtual void CreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest* request,
                               ::streamit::v1::CreateTopicResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest* request,
                               ::streamit::v1::CreateTopicResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest* request,
                                 ::streamit::v1::DescribeTopicResponse* response,
                                 std::function<void(::grpc::Status)>) = 0;
      virtual void DescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest* request,
                                 ::streamit::v1::DescribeTopicResponse* response,
                                 ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest* request,
                              ::streamit::v1::FindLeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest* request,
                              ::streamit::v1::FindLeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() {
      return nullptr;
    }
    class async_interface* experimental_async() {
      return async();
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>* AsyncCreateTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::CreateTopicResponse>* PrepareAsyncCreateTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>* AsyncDescribeTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::DescribeTopicResponse>*
    PrepareAsyncDescribeTopicRaw(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
                                 ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>* AsyncFindLeaderRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::streamit::v1::FindLeaderResponse>* PrepareAsyncFindLeaderRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
        ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
         const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
                               ::streamit::v1::CreateTopicResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>> AsyncCreateTopic(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>>(
          AsyncCreateTopicRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>> PrepareAsyncCreateTopic(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>>(
          PrepareAsyncCreateTopicRaw(context, request, cq));
    }
    ::grpc::Status DescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
                                 ::streamit::v1::DescribeTopicResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>> AsyncDescribeTopic(
        ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>>(
          AsyncDescribeTopicRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>> PrepareAsyncDescribeTopic(
        ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
        ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>>(
          PrepareAsyncDescribeTopicRaw(context, request, cq));
    }
    ::grpc::Status FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
                              ::streamit::v1::FindLeaderResponse* response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>> AsyncFindLeader(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>>(
          AsyncFindLeaderRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>> PrepareAsyncFindLeader(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>>(
          PrepareAsyncFindLeaderRaw(context, request, cq));
    }
    class async final : public StubInterface::async_interface {
    public:
      void CreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest* request,
                       ::streamit::v1::CreateTopicResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateTopic(::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest* request,
                       ::streamit::v1::CreateTopicResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest* request,
                         ::streamit::v1::DescribeTopicResponse* response, std::function<void(::grpc::Status)>) override;
      void DescribeTopic(::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest* request,
                         ::streamit::v1::DescribeTopicResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest* request,
                      ::streamit::v1::FindLeaderResponse* response, std::function<void(::grpc::Status)>) override;
      void FindLeader(::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest* request,
                      ::streamit::v1::FindLeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;

    private:
      friend class Stub;
      explicit async(Stub* stub) : stub_(stub) {
      }
      Stub* stub() {
        return stub_;
      }
      Stub* stub_;
    };
    class async* async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>* AsyncCreateTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::CreateTopicResponse>* PrepareAsyncCreateTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::CreateTopicRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>* AsyncDescribeTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::DescribeTopicResponse>* PrepareAsyncDescribeTopicRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::DescribeTopicRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>* AsyncFindLeaderRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
        ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader<::streamit::v1::FindLeaderResponse>* PrepareAsyncFindLeaderRaw(
        ::grpc::ClientContext* context, const ::streamit::v1::FindLeaderRequest& request,
        ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateTopic_;
    const ::grpc::internal::RpcMethod rpcmethod_DescribeTopic_;
    const ::grpc::internal::RpcMethod rpcmethod_FindLeader_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr<::grpc::ChannelInterface>& channel,
                                       const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CreateTopic(::grpc::ServerContext* context,
                                       const ::streamit::v1::CreateTopicRequest* request,
                                       ::streamit::v1::CreateTopicResponse* response);
    virtual ::grpc::Status DescribeTopic(::grpc::ServerContext* context,
                                         const ::streamit::v1::DescribeTopicRequest* request,
                                         ::streamit::v1::DescribeTopicResponse* response);
    virtual ::grpc::Status FindLeader(::grpc::ServerContext* context, const ::streamit::v1::FindLeaderRequest* request,
                                      ::streamit::v1::FindLeaderResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_CreateTopic() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTopic(::grpc::ServerContext* context, ::streamit::v1::CreateTopicRequest* request,
                            ::grpc::ServerAsyncResponseWriter<::streamit::v1::CreateTopicResponse>* response,
                            ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                            void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDescribeTopic(::grpc::ServerContext* context, ::streamit::v1::DescribeTopicRequest* request,
                              ::grpc::ServerAsyncResponseWriter<::streamit::v1::DescribeTopicResponse>* response,
                              ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                              void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithAsyncMethod_FindLeader() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindLeader(::grpc::ServerContext* context, ::streamit::v1::FindLeaderRequest* request,
                           ::grpc::ServerAsyncResponseWriter<::streamit::v1::FindLeaderResponse>* response,
                           ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                           void* tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateTopic<WithAsyncMethod_DescribeTopic<WithAsyncMethod_FindLeader<Service>>> AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_CreateTopic() {
      ::grpc::Service::MarkMethodCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::CreateTopicRequest,
                                                        ::streamit::v1::CreateTopicResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::CreateTopicRequest* request,
                        ::streamit::v1::CreateTopicResponse* response) {
                   return this->CreateTopic(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_CreateTopic(
        ::grpc::MessageAllocator<::streamit::v1::CreateTopicRequest, ::streamit::v1::CreateTopicResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::CreateTopicRequest,
                                                         ::streamit::v1::CreateTopicResponse>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateTopic(::grpc::CallbackServerContext* /*context*/,
                                                    const ::streamit::v1::CreateTopicRequest* /*request*/,
                                                    ::streamit::v1::CreateTopicResponse* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::DescribeTopicRequest,
                                                        ::streamit::v1::DescribeTopicResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::DescribeTopicRequest* request,
                        ::streamit::v1::DescribeTopicResponse* response) {
                   return this->DescribeTopic(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_DescribeTopic(
        ::grpc::MessageAllocator<::streamit::v1::DescribeTopicRequest, ::streamit::v1::DescribeTopicResponse>*
            allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::DescribeTopicRequest,
                                                         ::streamit::v1::DescribeTopicResponse>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DescribeTopic(::grpc::CallbackServerContext* /*context*/,
                                                      const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                                      ::streamit::v1::DescribeTopicResponse* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithCallbackMethod_FindLeader() {
      ::grpc::Service::MarkMethodCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<::streamit::v1::FindLeaderRequest,
                                                        ::streamit::v1::FindLeaderResponse>(
                 [this](::grpc::CallbackServerContext* context, const ::streamit::v1::FindLeaderRequest* request,
                        ::streamit::v1::FindLeaderResponse* response) {
                   return this->FindLeader(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_FindLeader(
        ::grpc::MessageAllocator<::streamit::v1::FindLeaderRequest, ::streamit::v1::FindLeaderResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler<::streamit::v1::FindLeaderRequest,
                                                         ::streamit::v1::FindLeaderResponse>*>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindLeader(::grpc::CallbackServerContext* /*context*/,
                                                   const ::streamit::v1::FindLeaderRequest* /*request*/,
                                                   ::streamit::v1::FindLeaderResponse* /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_CreateTopic<WithCallbackMethod_DescribeTopic<WithCallbackMethod_FindLeader<Service>>>
      CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_CreateTopic() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithGenericMethod_FindLeader() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_CreateTopic() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateTopic(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                            ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                            ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                            void* tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDescribeTopic(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                              ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                              ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                              void* tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawMethod_FindLeader() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindLeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request,
                           ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer>* response,
                           ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq,
                           void* tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_CreateTopic() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->CreateTopic(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateTopic(::grpc::CallbackServerContext* /*context*/,
                                                    const ::grpc::ByteBuffer* /*request*/,
                                                    ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->DescribeTopic(context, request, response); }));
    }
    ~WithRawCallbackMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DescribeTopic(::grpc::CallbackServerContext* /*context*/,
                                                      const ::grpc::ByteBuffer* /*request*/,
                                                      ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithRawCallbackMethod_FindLeader() {
      ::grpc::Service::MarkMethodRawCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer, ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request,
                        ::grpc::ByteBuffer* response) { return this->FindLeader(context, request, response); }));
    }
    ~WithRawCallbackMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FindLeader(::grpc::CallbackServerContext* /*context*/,
                                                   const ::grpc::ByteBuffer* /*request*/,
                                                   ::grpc::ByteBuffer* /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_CreateTopic() {
      ::grpc::Service::MarkMethodStreamed(
          0, new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::CreateTopicRequest,
                                                        ::streamit::v1::CreateTopicResponse>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerUnaryStreamer<::streamit::v1::CreateTopicRequest,
                                                    ::streamit::v1::CreateTopicResponse>* streamer) {
                   return this->StreamedCreateTopic(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_CreateTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateTopic(::grpc::ServerContext* /*context*/,
                               const ::streamit::v1::CreateTopicRequest* /*request*/,
                               ::streamit::v1::CreateTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateTopic(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::CreateTopicRequest, ::streamit::v1::CreateTopicResponse>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DescribeTopic : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_DescribeTopic() {
      ::grpc::Service::MarkMethodStreamed(
          1, new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::DescribeTopicRequest,
                                                        ::streamit::v1::DescribeTopicResponse>(
                 [this](::grpc::ServerContext* context,
                        ::grpc::ServerUnaryStreamer<::streamit::v1::DescribeTopicRequest,
                                                    ::streamit::v1::DescribeTopicResponse>* streamer) {
                   return this->StreamedDescribeTopic(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_DescribeTopic() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DescribeTopic(::grpc::ServerContext* /*context*/,
                                 const ::streamit::v1::DescribeTopicRequest* /*request*/,
                                 ::streamit::v1::DescribeTopicResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDescribeTopic(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::DescribeTopicRequest, ::streamit::v1::DescribeTopicResponse>*
            server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindLeader : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {
    }

  public:
    WithStreamedUnaryMethod_FindLeader() {
      ::grpc::Service::MarkMethodStreamed(
          2,
          new ::grpc::internal::StreamedUnaryHandler<::streamit::v1::FindLeaderRequest,
                                                     ::streamit::v1::FindLeaderResponse>(
              [this](::grpc::ServerContext* context,
                     ::grpc::ServerUnaryStreamer<::streamit::v1::FindLeaderRequest, ::streamit::v1::FindLeaderResponse>*
                         streamer) { return this->StreamedFindLeader(context, streamer); }));
    }
    ~WithStreamedUnaryMethod_FindLeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindLeader(::grpc::ServerContext* /*context*/, const ::streamit::v1::FindLeaderRequest* /*request*/,
                              ::streamit::v1::FindLeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindLeader(
        ::grpc::ServerContext* context,
        ::grpc::ServerUnaryStreamer<::streamit::v1::FindLeaderRequest, ::streamit::v1::FindLeaderResponse>*
            server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateTopic<
      WithStreamedUnaryMethod_DescribeTopic<WithStreamedUnaryMethod_FindLeader<Service>>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateTopic<
      WithStreamedUnaryMethod_DescribeTopic<WithStreamedUnaryMethod_FindLeader<Service>>>
      StreamedService;
};

} // namespace v1
} // namespace streamit

#include <grpcpp/ports_undef.inc>
#endif // GRPC_proto_2fstreamit_2eproto__INCLUDED
